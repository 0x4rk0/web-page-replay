<script type="text/javascript" src="server.js"></script>

<script>
// TODO(mbelshe): Remove all these console.log statements

// Configuration and results are stored globally.
window.iterations = 10;
window.interval = 300;
window.loadCheck = 0;
window.timeout = 15000;  // Max ms before killing page.
window.maxLoadChecks = Math.round(window.timeout / window.interval);
window.clearConnections = true;
window.clearCache = true;
window.enableSpdy = false;
window.windowId = 0;
window.submitter;

// Map the WebTiming property to the name we use to log it.
window.loggedTimings = {
  fetchStart: 'start_load_time',
  domainLookupEnd: 'dns_time',
  connectEnd: 'connect_time',
  responseStart: 'first_byte_time',
  responseEnd: 'last_byte_time',
  domInteractive: 'doc_load_time',
  domContentLoadedEventEnd: 'dcl_time',
  loadEventEnd: 'total_time',
};

// This is to be provided by the benchmark starter
window.benchmarkConfiguration = {};

// Constant StatCounter Names
var kTCPReadBytes = "tcp.read_bytes";
var kTCPWriteBytes = "tcp.write_bytes";
var kRequestCount = "HttpNetworkTransaction.Count";
var kConnectCount = "tcp.connect";
var kSpdySessionCount = "spdy.sessions";

// The list of currently running benchmarks
var benchmarks = [];
var benchmarkIndex = 0;
var benchmarkWindow = 0;

function CHECK(expr, comment) {
  if (!expr) {
    console.log(comment);
    alert(comment);
  }
}

// Close all open tabs
function closeAllTabs() {
  chrome.tabs.getAllInWindow(null, function(tabs) {
    tabs.forEach(function(tab) {
      chrome.tabs.remove(tab.id);
    });
  });
}

function addBenchmark(benchmark) {
  benchmarks.push(benchmark);
  set_summary_stats.url_count++;
}

// Array Remove - By John Resig (MIT Licensed)
Array.prototype.remove = function(from, to) {
  var rest = this.slice((to || from) + 1 || this.length);
  this.length = from < 0 ? this.length + from : from;
  return this.push.apply(this, rest);
};

function currentBenchmark() {
  if (benchmarkIndex >= benchmarks.length) {
    return undefined;
  }
  return benchmarks[benchmarkIndex];
}

// Find the next benchmark with iterations to run.
// Return null if all benchmarks are done.
function nextBenchmark() {
  CHECK(benchmarks.length > 0, "nextBenchmark has no benchmarks to run");
  var index = benchmarkIndex;
  do {
    benchmarkIndex = (benchmarkIndex + 1) % benchmarks.length;
    console.log("incremented benchmark Index to " + benchmarkIndex);
  } while (index != benchmarkIndex &&
           !benchmarks[benchmarkIndex].hasMoreIterations());
  if (!benchmarks[benchmarkIndex].hasMoreIterations()) {
    console.log("nextBenchmark: everything is done!");
    return null;   // We looped through the entire list!
  }
  return benchmarks[benchmarkIndex];
}

set_summary_stats = {}
set_summary_stats.url_count = 0;
set_summary_stats.iterations = 0;
for (var prop in loggedTimings) {
  set_summary_stats[loggedTimings[prop]] = 0;
}
set_summary_stats.paint_time = 0;
set_summary_stats.read_bytes_kb = 0;
set_summary_stats.write_bytes_kb = 0;
set_summary_stats.num_requests = 0;
set_summary_stats.num_connects = 0;
set_summary_stats.num_sessions = 0;

function Benchmark(url) {
  var runCount_ = 0;
  var me_ = this;
  var current_;
  var initialRequestCount_;
  var initialReadBytes_;
  var initialWriteBytes_;
  var isActive_ = false;  // True only when this benchmark has a page running.
  var startTime_ = new Date();

  console.log("Benchmark testing url: " + url);
  runCount_ = window.iterations;
  current_ = {};
  current_.url = url;
  current_.iterations = 0;
  current_.using_spdy = false;
  for (var prop in loggedTimings) {
    current_[loggedTimings[prop]] = [];
  }
  current_.paint_time = [];
  current_.read_bytes_kb = [];
  current_.write_bytes_kb = [];
  current_.num_requests = [];
  current_.num_connects = [];
  current_.num_sessions = [];

  // Add this benchmark to the list of benchmarks running.
  addBenchmark(this);

  // Is the benchmark currently in progress.
  this.hasMoreIterations = function() {
    if (runCount_ <= 0) { return false; }

    // Dynamically look at the current results and see if the variance is low
    // enough to warrant no longer testing this page.  To do this, we're
    // using a normal approximate to the distribution of the sample variance.
    // You can read more about this here:
    // http://en.wikipedia.org/wiki/Normal_distribution#Estimation_of_parameters
    // Basically this means we're using a metric similar to the stderr, but
    // which requires twice the samples:
    //     error = stddev / sqrt(n/2)
    var kMinIterationsBeforeStop = 5;
    var kMinErrorBeforeStop = .02;  // 2%

    var results = current_[loggedTimings['loadEventEnd']];
    var num_iterations = results.length;
    if (num_iterations >= kMinIterationsBeforeStop) {
      var mean = Array.mean(results);
      var stddev = Array.stddev(results);
      var error = stddev / Math.sqrt(num_iterations / 2);
      var ratio = error / mean;

      console.log(url + ": CHECKED EARLY BAIL: " + num_iterations +
                  " iterations, stddev=" + stddev + ", error=" + error);

      if (ratio <= kMinErrorBeforeStop) {
        console.log("Variance is good enough for url: " + this.url() + 
                    ", iterations: " + num_iterations +
                    ", stddev: " + stddev +
                    ", error: " + error +
                    ", ratio: " + ratio);
        runCount_ = 0;
        return false;
      }
    }
    
    return true;
  }

  this.isActive = function() {
    return isActive_;
  }

  this.startTime = function() {
    return startTime_;
  }

  this.abortPageLoad = function() {
    console.log("running abortPageLoad for: " + me_.url());
    isActive_ = false;
    me_.pageFinished();
  }

  // The url which this benchmark is running.
  this.url = function() { return current_.url; }

  // Called when the test run completes.
  this.pageFinished = function() {
    console.log("running pageFinished for: " + me_.url());
    runCount_--;

    var benchmark = nextBenchmark();
    var finished = false;
    if (benchmark == null) {
      console.log("Benchmark is finished!");
      finished = true;
    }

    if (!me_.hasMoreIterations()) {
      // Update the overall set to include this summary.
      set_summary_stats.iterations = Math.max(set_summary_stats.iterations,
                                              current_.iterations);
      for (var prop in loggedTimings) {
        set_summary_stats[loggedTimings[prop]] +=
          Array.mean(current_[loggedTimings[prop]]);
      }
      set_summary_stats.paint_time += Array.mean(current_.paint_time);
      set_summary_stats.read_bytes_kb += Array.mean(current_.read_bytes_kb);
      set_summary_stats.write_bytes_kb += Array.mean(current_.write_bytes_kb);
      set_summary_stats.num_requests += Array.mean(current_.num_requests);
      set_summary_stats.num_connects += Array.mean(current_.num_connects);
      set_summary_stats.num_sessions += Array.mean(current_.num_sessions);

      window.submitter.PostSummary(current_, function(response) {
        console.log("Posted summary: " + response);
        if (finished) {
          // If we're the last benchmark, close the window.
          console.log("removing benchmark window: " + benchmarkWindow.id);
          window.submitter.UpdateSetSummary(set_summary_stats,
                                            function(response) {
            console.log("Posted set summary: " + response);
            chrome.tabs.remove(benchmarkWindow.id);
            benchmarkWindow = 0;
            closeAllTabs();

            // On mac, closing all tabs doesn't close Chrome, so crash after a timeout.
            setTimeout(function() {
              chrome.windows.create({"url": "about:inducebrowsercrashforrealz"});
            }, 1000);
          });
        }
      });
    } 

    if (!finished) {
      // Move on to next benchmarked pages.
      setTimeout(benchmark.runPage, window.interval);
    }
  }

  // Called before starting a page load.
  this.pageStart = function() {
    console.log("pageStart for " + this.url());
    initialReadBytes_ = chrome.benchmarking.counter(kTCPReadBytes);
    initialWriteBytes_ = chrome.benchmarking.counter(kTCPWriteBytes);
    initialRequestCount_ = chrome.benchmarking.counter(kRequestCount);
    initialConnectCount_ = chrome.benchmarking.counter(kConnectCount);
    initialSpdySessionCount_ = chrome.benchmarking.counter(kSpdySessionCount);

    startTime_ = new Date();
    CHECK(!isActive_, "activating already active benchmark");
    isActive_ = true;
  }

  this.openNextPage = function() {
    var benchmark = currentBenchmark();
    console.log("openNextPage called. current = " + benchmark.url());
    benchmark.pageStart();

    // We don't trust the tab creation to succeed, so start a timer
    // that is cleared when the tab is created.
    var hangTimer = setTimeout(function() {
      // It is unlikely but possible for this to get enqueued after
      // create tabs completes. In this case, loadCheck will have
      // been cleared, but checkForLoad will not have fired yet.
      // So, bail out if loadCheck is zero.
      if (!window.loadCheck) return;

      console.log("chrome.tabs.create failed for " + benchmark.url());
      benchmark.abortPageLoad();
    }, window.timeout);

    chrome.tabs.create({"url": benchmark.url(),
                        "selected": true
                       },
                       function(tab) {
                         clearTimeout(hangTimer);
                         benchmarkWindow = tab;
                         console.log("Created benchmark tab: " + tab.id);
                         window.loadCheck = 0;
                         me_.checkForLoadId = setInterval(function(){
                           benchmark.checkForLoad(tab);
                         }, window.interval);
                       });
  }

  this.prepareToOpenPage = function() {
    console.log("prepareToOpenPage called");
    // After the previous page is closed, this function will apply
    // any settings needed to prepare for opening a new page.
    // Note: the previous page must be closed, otherwise, the cache
    // clearing and connection clearing may not be thorough.

    if (window.clearCache) {
      chrome.benchmarking.clearCache();
    }

    if (window.clearConnections) {
      chrome.benchmarking.closeConnections();
    }

    // Go back to the browser so that tasks can run.
    setTimeout(me_.openNextPage, window.interval);
  }

  // Run a single page in the benchmark
  this.runPage = function() {
    if (benchmarkWindow) {
      console.log("Closing benchmark window: " + benchmarkWindow.id);
      var tab_id = benchmarkWindow.id;
      benchmarkWindow = 0;
      chrome.tabs.remove(tab_id, function() {
        me_.prepareToOpenPage();
      });
    } else {
      me_.prepareToOpenPage();
    }
  }

  this.checkForLoad = function(tab) {
    console.log("Sending load time request to tab: " + tab.id);
    window.loadCheck++;
    if (window.loadCheck > window.maxLoadChecks) {
      clearInterval(me_.checkForLoadId);
      me_.abortPageLoad();
      return;
    }      
    chrome.tabs.sendRequest(tab.id, {}, function(response) {
      if (response.timing.loadEventEnd && response.loadTimes.finishLoadTime) {
        clearInterval(me_.checkForLoadId);
        console.log("Load complete for tab: " + tab.id);

        // If it record mode, wait here another 10 seconds to be absolutely
        // sure that any lazy loaded resources are recorded.
        if (benchmarkConfiguration.record) {
          setTimeout(function() {
            me_.pageLoaded(response.loadTimes, response.timing);
          }, 10000);
        } else {
          me_.pageLoaded(response.loadTimes, response.timing);
        }
      }
    });
  }

  // Called when a page finishes loading.
  this.pageLoaded = function(load_times, timing) {
    console.log("pageLoaded");

    if (!isActive_) {
      // The page is already dead.  It was probably killed and finished
      // at the same time.
      console.log("page is no longer active!");
      return;
    }
    isActive_ = false;

    // Make sure the content can be fetched via spdy if it is enabled.
    if (window.enableSpdy && !load_times.wasFetchedViaSpdy) {
      alert("Can not fetch current url via spdy.\n" +
            "Ending current test.");
      runCount_ = 0;  // Stop running this test.
      me_.pageFinished();
      return;
    }

    // If last fetch was via spdy, current fetch should use spdy too. Same
    // for vise versa.
    if (current_.iterations > 0 &&
        current_.using_spdy != load_times.wasFetchedViaSpdy) {
      alert("Error: viaSpdy for current fetch is different from last fetch!\n" +
            "Ending current test.");
      runCount_ = 0;  // Stop running this test.
      me_.pageFinished();
      return;
    }

    // Record the individual result
    var result = {}
    var baseTime = timing.navigationStart;
    CHECK(baseTime);
    for (var prop in loggedTimings) {
      if (prop in timing) {
        result[loggedTimings[prop]] = timing[prop] - baseTime;
      }
    }
    result.paint_time = load_times.firstPaintTime ? Math.round((1000.0 * load_times.firstPaintTime) - baseTime) : 0;
    result.url = current_.url;
    result.using_spdy = load_times.wasFetchedViaSpdy;
    var bytesRead = chrome.benchmarking.counter(kTCPReadBytes) -
                                                initialReadBytes_;
    var bytesWrite = chrome.benchmarking.counter(kTCPWriteBytes) - 
                                                 initialWriteBytes_;
    result.read_bytes_kb = bytesRead / 1024;
    result.write_bytes_kb = bytesWrite / 1024;
    result.num_requests = chrome.benchmarking.counter(kRequestCount) -
        initialRequestCount_;
    result.num_connects = chrome.benchmarking.counter(kConnectCount) -
        initialConnectCount_;
    result.num_sessions = chrome.benchmarking.counter(kSpdySessionCount) -
        initialSpdySessionCount_;

    // Record the aggregate result for this URL.
    current_.iterations++;
    for (var prop in loggedTimings) {
      if (loggedTimings[prop] in result) {
        current_[loggedTimings[prop]].push(result[loggedTimings[prop]]);
      }
    }
    current_.paint_time.push(result.paint_time);
    current_.using_spdy = result.using_spdy;
    current_.read_bytes_kb.push(result.read_bytes_kb);
    current_.write_bytes_kb.push(result.write_bytes_kb);
    current_.num_requests.push(result.num_requests);
    current_.num_connects.push(result.num_connects);
    current_.num_sessions.push(result.num_sessions);

    // Submit the result.
    window.submitter.PostResult(result, function(response) {
      console.log("Posted result for " + me_.url + ": " + response);
      me_.pageFinished();
    });
  }
}

chrome.extension.onConnect.addListener(function(port) {
  port.onMessage.addListener(function(data) {
    if (data.message == "start") {
      window.benchmarkConfiguration = data.benchmark;
      window.submitter = new TestResultSubmitter(benchmarkConfiguration);
      window.submitter.CreateTest(function() { run(); });
      return;
    }
  });
});

function run() {
  window.iterations = benchmarkConfiguration.iterations;
  window.enableSpdy = benchmarkConfiguration.protocol == "spdy" ||
                      benchmarkConfiguration.protocol == "spdy-nossl";

  if (window.clearCache) {
    // Show a warning if we will try to clear the cache between runs
    // but will also be reusing the same WebKit instance (i.e. Chrome
    // is in single-process mode) because the WebKit cache might not get
    // completely cleared between runs.
    if (chrome.benchmarking.isSingleProcess()) {
      alert("Warning: the WebKit cache may not be cleared correctly " +
            "between runs because Chrome is running in single-process mode.");
    }
  }

  benchmarks = [];
  var urls = benchmarkConfiguration.urls;
  for (var i = 0; i < urls.length; i++) {
    // Remove extra space at the beginning or end of a url.
    urls[i] = removeSpace(urls[i]);

    // Alert about and ignore blank page which does not get loaded. 
    if (urls[i] == "about:blank") {
      alert("blank page loaded!");
    } else if (!checkScheme(urls[i])) {
      // Alert about url that is not in scheme http:// or https://.
      alert(urls[i] + " does not start with http:// or https://.");
    } else {  
      var benchmark = new Benchmark(urls[i]);
    }
  }
  benchmarks[0].runPage();
}

// Remove extra whitespace in the beginning or end of a url string.
function removeSpace(url) {
  var tempUrl = url;
  while (tempUrl.charAt(tempUrl.length-1) == " ") {
    tempUrl = tempUrl.substring(0, tempUrl.length-1);
  };
  while (tempUrl.charAt(0) == " ") {
    tempUrl = tempUrl.substring(1, tempUrl.length);
  };
  return tempUrl;
}

// Check whether a Url starts with http:// or https://.
function checkScheme(url) {
  var httpStr = "http://";
  var httpsStr = "https://";
  var urlSubStr1 = url.substring(0, httpStr.length);
  var urlSubStr2 = url.substring(0, httpsStr.length);
  
  if ( (urlSubStr1 == httpStr) || (urlSubStr2 == httpsStr) ) {
    return true;
  } 
  return false; 
}

// Run at startup
chrome.windows.getCurrent(function(currentWindow) {
  window.windowId = currentWindow.id;
});
</script>
